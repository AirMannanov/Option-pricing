# Техническое задание  
**Проект:** Инструмент для прайсинга опционов  
**Язык реализации:** C++  

---

## 1. Область применения и сценарии

Инструмент предназначен для расчёта справедливой стоимости и греков ванильных опционов на акции.  
Основной сценарий использования:

1. Пользователь передаёт параметры опциона (тип, цена страйк, цена базового актива, срок до экспирации, волатильность, безрисковая ставка).
2. Программа считает цену опциона по выбранной модели.
3. Программа возвращает результат в человекочитаемом или машинно-читаемом виде.

Поддерживаемые типы опционов:
- Европейский Call
- Европейский Put

---

## 2. Функциональные требования

### 2.1. Расчёт цены опциона (MVP)

1. Программа должна уметь рассчитать цену европейского call/put по модели Блэка–Шоулза.
2. Параметры, обязательные для расчёта:
   - `S` — текущая цена базового актива
   - `K` — страйк
   - `T` — время до экспирации (в годах / днях, с конвертацией к годам)
   - `r` — безрисковая ставка
   - `σ` — волатильность (годовая)
   - `option_type` — `call` или `put`

### 2.2. Расчёт греков

1. По тем же входным данным программа может вычислить:
   - Delta
   - Gamma
   - Vega
   - Theta
   - Rho
2. Вывод греков должен быть опциональной функцией (флаг в командной строке).

### 2.3. Режимы работы

1. **Одиночный расчёт (MVP)**  
   Ввод параметров через аргументы командной строки либо через интерактивные вопросы в консоли.  
   Вывод результата в текстовом виде.

2. **Пакетный расчёт**  
   - Вход: CSV-файл с набором опционов (одна строка – один опцион).  
   - Выход: CSV-файл с рассчитанными ценами и греками.

---

## 3. Технические требования

### 3.1. Язык и стандарт

- C++17 (или выше, если удобно, но без сложных фич).
- Кроссплатформенная сборка: Linux / macOS.

### 3.2. Сборка

1. Использовать CMake в качестве системы сборки.
2. Собирать два таргета:
   - статическая/динамическая библиотека с ядром прайсинга (`libpricing`)
   - консольное приложение (`option_pricer_cli`).
3. Поддержать конфигурации `Debug` и `Release`.

### 3.3. Структура проекта (пример)

- `src/`
  - `core/` – доменные сущности (Option, MarketData, PricingModel)
  - `models/` – реализации моделей (BlackScholesModel, BinomialModel)
  - `cli/` – парсинг аргументов, запуск сценариев
- `include/` – публичные заголовки библиотеки
- `tests/` – модульные тесты
- `docs/` – документация (описание API, инструкции по запуску)
- `examples/` – примеры входных файлов

### 3.4. Зависимости

- Стандартная библиотека C++.
- Библиотека для тестирования Catch2.

---

## 4. Требования к производительности

- Система должна выполнять не менее 80% типовых запросов (расчёт цены опциона с греками
  по модели Блэка–Шоулза) за время не более 1 секунды на условной машине:
  - до 10 000 опционов в пакетном режиме.

(Чёткое измерение оформляется отдельным небольшим бенчмарком или скриптом.)

---

## 5. Дизайн программной архитектуры

### 5.1. Основные сущности

- `Option` – тип опциона, страйк, срок, тип исполнения.
- `MarketData` – цена базового актива, волатильность, безрисковая ставка.
- `PricingModel` (интерфейс) – метод `price()` и методы для вычисления греков.
- `BlackScholesModel` – реализация `PricingModel`.

### 5.2. Слой приложения

- `PricingService` – принимает на вход `Option` и `MarketData`,
  выбирает модель и возвращает результат (`PricingResult`).
- `CliController` – отвечает за:
  - разбор аргументов командной строки;
  - выбор режима (одиночный / пакетный);
  - форматирование вывода.

### 5.3. Обработка ошибок

- Проверка корректности входных данных (отрицательная волатильность, нулевой срок и т.п.).
- Возврат понятных сообщений об ошибках в stderr и ненулевой exit-code.

---

## 6. Требования к коду и репозиторию

1. Код хранится в Git-репозитории.
2. В репозитории должны быть:
   - `README.md` с описанием:
     - постановки задачи;
     - инструкции по сборке и запуску;
     - примеров использования.
3. Стиль кода – самодокументируемый:
   - Понятные имена переменных и функций.
   - Минимум комментариев, только там, где логика неочевидна.
   - Разбиение на небольшие функции/классы.

---

## 7. Тестирование

1. **Модульные тесты (MVP)**:
   - Тесты для `BlackScholesModel`:
     - сравнение с заранее посчитанными эталонными значениями (несколько сценариев).
   - Тесты валидации входных данных.
2. **Интеграционные тесты (желательно)**:
   - Тест запуска CLI с примером CSV и проверкой выходного файла.

---

## 8. Минимальный объём работ

1. Реализовать:

   * модель Блэка–Шоулза (цена call/put);
   * CLI для одиночного расчёта;
   * несколько модульных тестов;
   * CMake-сборку (библиотека + CLI).
2. Описать архитектуру и сценарии в `README.md`.
3. Обеспечить выполнение базового требования по производительности
   на небольшом наборе опционов (до 10k).
